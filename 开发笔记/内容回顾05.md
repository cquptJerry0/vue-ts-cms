# 内容回顾

## 一. 高阶组件封装

### 1.1. PageContent

- header
- propsList
  - 插槽 => 作用于插槽 => 完全的定制化
- pageName

### 1.2. PageModal

配置文件:

- pageName

- header:
  - newTitle
  - editTitle
- formItems
  - el-form-item => el-input/el-select

某些select的options数据来自服务器

- modalConfig => mainStore => computed

### 1.3. 页面hooks抽取

- usePageContent
- usePageModal

### 1.4. 小bug的处理

- 多余的导入文件
- defineProps<不能来自文件引入>()

## 二. 页面的细节处理

### 2.1. 菜单的页面

- 展示子菜单
  - row-key

### 2.2. PageModal自定义插槽

### 2.3. ElTree的展示

- 获取完整的菜单
- 创建角色时, 携带选中的菜单
  - otherInfo属性

### 2.4. 编辑角色数据回显

- mapMenuListToIds
- elTree.value?.setCheckKeys([])

### 2.5. nextTick

- 使用场景
- 原理
- 源码

## 三. 使用Keep-Alive优化页面切换性能

### 3.1. 在 main.vue 中使用 Keep-Alive

在主布局组件中使用 Keep-Alive 可以缓存路由组件，避免重复创建和销毁，提高性能和用户体验：

```vue
<el-main>
  <router-view v-slot="{ Component }">
    <keep-alive :include="cacheRoutes">
      <component :is="Component" />
    </keep-alive>
  </router-view>
</el-main>
```

通过 v-slot API 获取当前渲染的组件，然后在 keep-alive 中包裹它。`:include` 属性用于控制哪些组件需要被缓存。

在 script 部分需要定义 cacheRoutes 数组：

```vue
<script setup lang="ts">
  import { ref, computed } from 'vue'
  import useCacheStore from '@/store/cache/cache'

  // 其他代码...

  // 获取需要缓存的路由
  const cacheStore = useCacheStore()
  const cacheRoutes = computed(() => cacheStore.cacheRoutes)
</script>
```

### 3.2. 创建 cache store 管理缓存路由

可以创建一个专门的 store 来管理需要缓存的组件列表，实现更灵活的缓存控制：

```typescript
// src/store/cache/cache.ts
import { defineStore } from 'pinia'
import { ref } from 'vue'

const useCacheStore = defineStore('cache', () => {
  // 默认缓存的路由组件名称列表
  const cacheRoutes = ref<string[]>([
    'user',
    'role',
    'department',
    'menu',
    'category',
    'goods',
  ])

  // 添加缓存路由
  function addCacheRoute(routeName: string) {
    if (!cacheRoutes.value.includes(routeName)) {
      cacheRoutes.value.push(routeName)
    }
  }

  // 移除缓存路由
  function removeCacheRoute(routeName: string) {
    const index = cacheRoutes.value.indexOf(routeName)
    if (index !== -1) {
      cacheRoutes.value.splice(index, 1)
    }
  }

  return {
    cacheRoutes,
    addCacheRoute,
    removeCacheRoute,
  }
})

export default useCacheStore
```

### 3.3. 确保组件有正确的名称

Keep-Alive 组件通过组件的 name 属性来匹配需要缓存的组件。因此，所有需要被缓存的组件都必须有一个唯一的 name：

对于 `<script setup>` 语法，需要显式设置 name 属性：

```vue
<script setup lang="ts" name="user">
  // 组件代码
</script>
```

对于选项式 API：

```vue
<script lang="ts">
  export default {
    name: 'user',
    // 其他选项
  }
</script>
```

### 3.4. 基于路由元信息配置缓存

可以在路由配置中通过 meta 元信息标记哪些组件需要被缓存，然后在应用启动时自动生成缓存列表：

```typescript
// 路由配置示例
const routes = [
  {
    path: '/main/system/user',
    name: 'user',
    component: () =>
      import('@/views/main/system/user/user.vue'),
    meta: {
      keepAlive: true, // 标记该路由需要被缓存
    },
  },
  // 其他路由...
]
```

然后修改 cache store，根据路由元信息自动生成缓存列表：

```typescript
// src/store/cache/cache.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import router from '@/router'

const useCacheStore = defineStore('cache', () => {
  // 手动设置的缓存路由
  const manualCacheRoutes = ref<string[]>([])

  // 计算属性：合并路由元信息中的缓存配置和手动设置的缓存
  const cacheRoutes = computed(() => {
    // 从路由元信息中提取需要缓存的路由名称
    const routesFromMeta = router
      .getRoutes()
      .filter((route) => route.meta.keepAlive)
      .map((route) => route.name as string)
      .filter(Boolean)

    // 合并并去重
    return [
      ...new Set([
        ...routesFromMeta,
        ...manualCacheRoutes.value,
      ]),
    ]
  })

  // 添加手动缓存路由
  function addCacheRoute(routeName: string) {
    if (!manualCacheRoutes.value.includes(routeName)) {
      manualCacheRoutes.value.push(routeName)
    }
  }

  // 移除手动缓存路由
  function removeCacheRoute(routeName: string) {
    const index = manualCacheRoutes.value.indexOf(routeName)
    if (index !== -1) {
      manualCacheRoutes.value.splice(index, 1)
    }
  }

  return {
    cacheRoutes,
    addCacheRoute,
    removeCacheRoute,
  }
})

export default useCacheStore
```

### 3.5. 动态控制组件缓存

有时候需要根据用户操作动态控制组件缓存，例如在表单提交后刷新页面数据：

```typescript
// 在某个组件中
import { useRouter } from 'vue-router'
import useCacheStore from '@/store/cache/cache'

const router = useRouter()
const cacheStore = useCacheStore()
const currentRouteName = router.currentRoute.value
  .name as string

// 临时移除缓存，强制组件重新创建
function refreshCurrentPage() {
  // 先移除缓存
  cacheStore.removeCacheRoute(currentRouteName)

  // 使用 nextTick 确保在 DOM 更新循环结束后再添加回缓存
  nextTick(() => {
    cacheStore.addCacheRoute(currentRouteName)
  })
}
```

### 3.6. 配合 activated 和 deactivated 生命周期钩子

使用 Keep-Alive 缓存的组件会触发 activated 和 deactivated 生命周期钩子，可以利用这些钩子执行一些特定操作：

```vue
<script setup lang="ts" name="user">
  import { onActivated, onDeactivated } from 'vue'

  // 组件被激活时触发（从缓存中恢复）
  onActivated(() => {
    console.log('用户列表组件被激活')
    // 可以在这里刷新一些实时性要求高的数据
    // 例如在表格组件切换回来时，可以重新获取最新数据
  })

  // 组件被缓存时触发
  onDeactivated(() => {
    console.log('用户列表组件被缓存')
    // 可以在这里做一些清理工作
    // 例如取消未完成的请求等
  })
</script>
```
